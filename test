<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Many-Objective Visualization (Python-Powered)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.1/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
        }
        
        #container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        #header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #b8c6db;
            font-size: 14px;
        }
        
        .python-badge {
            display: inline-block;
            background: linear-gradient(135deg, #3776ab, #ffd43b);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .viz-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
            position: relative;
        }
        
        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2a5298;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-subtitle {
            font-size: 11px;
            color: #666;
            font-weight: normal;
        }
        
        #radviz-3d {
            height: 450px;
            grid-column: 1 / 3;
        }
        
        #radviz-canvas {
            width: 100%;
            height: 380px;
            cursor: grab;
            border: 1px solid #555;
            border-radius: 8px;
            background: #2a2a3e;
        }
        
        #radviz-canvas:active {
            cursor: grabbing;
        }
        
        #controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            color: #333;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        select {
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #667eea;
            background: white;
        }
        
        #stats-bar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            color: #333;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2a5298;
        }
        
        .sample-tooltip {
            position: absolute;
            background: rgba(30, 30, 30, 0.95);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 350px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 126, 234, 0.5);
            display: none;
        }
        
        .sample-tooltip.show {
            display: block;
        }
        
        .tooltip-header {
            font-weight: bold;
            color: #64ffda;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>Many-Objective Bayesian Optimization Visualization</h1>
            <div class="subtitle">Handling 7 CFD objectives with 5 design variables and 3 constraints</div>
            <div class="python-badge">üêç Python-Generated Data (30 samples)</div>
        </div>
        
        <div id="main-grid">
            <div class="viz-panel" id="radviz-3d">
                <div class="panel-title">
                    <span id="radviz-title">üåê 3D RadViz</span>
                    <span class="panel-subtitle">7 objectives as anchor points pulling samples</span>
                </div>
                <div style="position: relative;">
                    <canvas id="radviz-canvas"></canvas>
                    <div id="radviz-2d" style="display: none; width: 100%; height: 380px;"></div>
                    <div style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 5px; font-size: 10px; color: white; border: 1px solid #333;">
                        <div style="margin-bottom: 4px;"><span style="color: #00ff00;">‚óè</span> Feasible</div>
                        <div style="margin-bottom: 4px;"><span style="color: #ff0000;">‚óè</span> Infeasible</div>
                        <div><span style="color: #ffd700;">‚òÖ</span> Pareto</div>
                    </div>
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
                    <button onclick="toggle2D3D()" style="padding: 5px 10px; font-size: 12px;">Switch to 2D</button>
                    <button onclick="resetRadVizCamera()" style="padding: 5px 10px; font-size: 12px;">Reset View</button>
                    <button onclick="toggleRadVizRotation()" style="padding: 5px 10px; font-size: 12px;">Toggle Rotation</button>
                    <select id="sphere-coloring" onchange="updateSphereColoring()" style="padding: 5px; font-size: 12px;">
                        <option value="none">Sphere: None</option>
                        <option value="feasibility">Sphere: Feasibility</option>
                        <option value="obj0">Sphere: Pressure Recovery</option>
                        <option value="obj1">Sphere: Mixing Efficiency</option>
                        <option value="obj2">Sphere: Heat Transfer</option>
                        <option value="obj3">Sphere: Turbulence</option>
                        <option value="obj4">Sphere: Wall Shear</option>
                        <option value="obj5">Sphere: Flow Uniformity</option>
                        <option value="obj6">Sphere: Energy Dissip.</option>
                        <option value="constraints">Sphere: Constraints</option>
                    </select>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #666;">
                        <input type="checkbox" id="show-sphere" checked> Show Sphere
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: #666;">
                        Opacity: <input type="range" id="sphere-opacity" min="10" max="90" value="30" style="width: 60px;" onchange="updateSphereOpacity()">
                    </label>
                </div>
            </div>
            
            <div class="viz-panel" id="constraints-panel">
                <div class="panel-title">
                    ‚ö†Ô∏è Constraints Status
                    <span class="panel-subtitle">Real-time monitoring</span>
                </div>
                <div id="constraints-display" style="padding: 10px;"></div>
            </div>
            
            <div class="viz-panel" id="radar-chart">
                <div class="panel-title">
                    üéØ Radar Chart
                    <span class="panel-subtitle">Last 5 samples</span>
                </div>
                <div id="radar-plot"></div>
            </div>
            
            <div class="viz-panel" id="constraint-heatmap" style="grid-column: 1 / 3;">
                <div class="panel-title">
                    üî• Objectives Heatmap
                    <span class="panel-subtitle">Sample √ó Objective matrix view</span>
                </div>
                <div id="heatmap-plot"></div>
            </div>
        </div>
        
        <div id="controls">
            <button onclick="showPythonInfo()">üìä Show Python Info</button>
            <button onclick="focusParetoFront()">‚≠ê Highlight Pareto</button>
            <button onclick="exportData()">üíæ Export Data</button>
        </div>
        
        <div id="stats-bar">
            <div class="stat-item">
                <div class="stat-label">Samples</div>
                <div class="stat-value" id="samples-count">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Hypervolume</div>
                <div class="stat-value" id="hypervolume">0.00</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Feasible</div>
                <div class="stat-value" id="feasible">0/0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Pareto Points</div>
                <div class="stat-value" id="pareto-count">0</div>
            </div>
        </div>
    </div>
    
    <div class="sample-tooltip" id="tooltip"></div>

    <script>
        // ================================================
        // PYTHON DATA INJECTION
        // ================================================
        const pythonData = {
  "samples": [
    {
      "id": 0,
      "design": [
        0.16231297860818805,
        -0.9976849596650195,
        -0.1256679792762727,
        -0.4692873642576141,
        -0.8278596994928251
      ],
      "objectives": [
        0.7375487710512572,
        0.6188565244791954,
        0.5176616935101389,
        0.9493732676863229,
        0.5765202474203064,
        0.6090367267540321,
        0.40678774559951086
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176187
    },
    {
      "id": 1,
      "design": [
        0.7780295214272777,
        -0.7597064989809355,
        0.9467280634956103,
        -0.9438873977439666,
        0.4498453326487488
      ],
      "objectives": [
        0.7288713517969475,
        0.625863890044313,
        0.5408465942809226,
        0.8673762706024895,
        0.1199637811299181,
        0.6222202747702049,
        0.2968258746342384
      ],
      "constraints": [
        true,
        false,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.6271549537484221,
      "timestamp": 1756801176187
    },
    {
      "id": 2,
      "design": [
        -0.8272947972613018,
        0.7646905147073078,
        0.25499272324847966,
        0.5504579843635862,
        0.5772801571080683
      ],
      "objectives": [
        0.6975047415484196,
        0.8466662593523882,
        0.9108827353150808,
        0.9620581260692393,
        0.5946676561810423,
        0.6260177662135518,
        0.26074662507207147
      ],
      "constraints": [
        false,
        true,
        true
      ],
      "feasible": false,
      "feasibilityProb": 0.7087702209247193,
      "timestamp": 1756801176187
    },
    {
      "id": 3,
      "design": [
        0.7534502975241746,
        0.043722340340480725,
        0.141439310097506,
        0.49610996464763235,
        -0.5197362163890047
      ],
      "objectives": [
        0.9241375050700894,
        0.9852219297028713,
        1.0,
        0.9272824491992955,
        0.4427111284200484,
        0.8911283489212861,
        0.26289268522425363
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176187
    },
    {
      "id": 4,
      "design": [
        0.7923959871855843,
        0.8522556923805176,
        -0.10745479851099837,
        0.17663910543341355,
        -0.7378189281728447
      ],
      "objectives": [
        0.7487327139269777,
        0.7311817046228677,
        0.8633509369767303,
        0.921398526981426,
        0.5238868223472325,
        0.5729930392990883,
        0.3899155507990647
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176187
    },
    {
      "id": 5,
      "design": [
        0.3328965175119869,
        -0.6650021621858508,
        -0.7514692300608938,
        -0.37762085911992394,
        -0.4401580590943528
      ],
      "objectives": [
        0.7570345725787453,
        0.6071063795194758,
        0.5088271103289044,
        0.7901615593185286,
        0.4208474354528665,
        0.6646002472659747,
        0.4700006492537308
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176187
    },
    {
      "id": 6,
      "design": [
        -0.33992461711400024,
        -0.9562613859450588,
        0.6192525840674523,
        0.8135426430763764,
        0.17127563108423804
      ],
      "objectives": [
        0.707473491773073,
        0.6134406685223693,
        0.6641450128799778,
        0.969050280652653,
        0.44120021093831463,
        0.6212034711551715,
        0.06736603443896494
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.6782618924020607,
      "timestamp": 1756801176190
    },
    {
      "id": 7,
      "design": [
        -0.9210367710700211,
        0.9943396896345076,
        -0.5720116100285002,
        -0.8112115153965684,
        -0.5489536563709503
      ],
      "objectives": [
        0.7246841765749976,
        0.6149376617539136,
        0.49389618997936763,
        0.8993143142696997,
        0.6431613174696535,
        0.6190561783798327,
        0.43881990314750546
      ],
      "constraints": [
        false,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.46039882342594934,
      "timestamp": 1756801176193
    },
    {
      "id": 8,
      "design": [
        0.7352315977714239,
        -0.7718535633106982,
        -0.9939333710714897,
        0.8280711232587261,
        0.8507183750834677
      ],
      "objectives": [
        0.6895617675980293,
        0.6302751576784231,
        0.49108837197206806,
        0.8022128990401537,
        0.3146720955256535,
        0.6430740080523905,
        0.5276578190376526
      ],
      "constraints": [
        true,
        false,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.6109155820194307,
      "timestamp": 1756801176195
    },
    {
      "id": 9,
      "design": [
        0.0008497954149846443,
        0.9738787099012953,
        -0.758169118834896,
        -0.5389878373574175,
        0.872185337195321
      ],
      "objectives": [
        0.8152897202519886,
        0.5670304056773458,
        0.5111557876159485,
        0.8681412173477001,
        0.4149696486926336,
        0.6326866431052264,
        0.44381945801929296
      ],
      "constraints": [
        true,
        false,
        true
      ],
      "feasible": false,
      "feasibilityProb": 0.6927395874935891,
      "timestamp": 1756801176197
    },
    {
      "id": 10,
      "design": [
        -0.6508011298024485,
        -0.004347411262186851,
        0.9710975977056464,
        -0.7099702423149568,
        0.18960052349155232
      ],
      "objectives": [
        0.7288166456345446,
        0.7615475035638309,
        0.5011744210242914,
        1.0,
        0.5521216168884606,
        0.6598764223225831,
        0.2360110438252614
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.7311601214713552,
      "timestamp": 1756801176199
    },
    {
      "id": 11,
      "design": [
        -0.9240612851367225,
        -0.8869652947824851,
        -0.9135725615189882,
        -0.05063819604815856,
        0.6655175693512596
      ],
      "objectives": [
        0.6819040267193194,
        0.624463374557675,
        0.5392476819500693,
        0.9992087860234328,
        0.6206518758717227,
        0.7243738383047282,
        0.4936728666539865
      ],
      "constraints": [
        false,
        false,
        true
      ],
      "feasible": false,
      "feasibilityProb": 0.5130129486360175,
      "timestamp": 1756801176201
    },
    {
      "id": 12,
      "design": [
        -0.1655257137027868,
        0.8363292933650497,
        0.8111272196988331,
        -0.4980025435925901,
        -0.8028168618214127
      ],
      "objectives": [
        0.851209796618331,
        0.671186278974171,
        0.45439105827279935,
        0.9913920146239411,
        0.5946496231609856,
        0.6225155804227476,
        0.37341600820393395
      ],
      "constraints": [
        true,
        false,
        true
      ],
      "feasible": false,
      "feasibilityProb": 0.746802275692549,
      "timestamp": 1756801176204
    },
    {
      "id": 13,
      "design": [
        0.5050161956502452,
        0.5344691071551435,
        0.9666721892566381,
        -0.007838325685807668,
        0.4197912366928709
      ],
      "objectives": [
        0.8767879092345399,
        0.7430866436768888,
        0.5114323197535647,
        0.793488672619704,
        0.021568093907529923,
        0.7201606173694395,
        0.3119763144546709
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176206
    },
    {
      "id": 14,
      "design": [
        -0.9145284029365006,
        0.1228132572471956,
        -0.313843703526721,
        0.49043136533418363,
        -0.7205508160254421
      ],
      "objectives": [
        0.7037004569307551,
        0.7910763915388299,
        0.7823839333120431,
        0.9887811800200315,
        0.5761873070047236,
        0.8542579776971496,
        0.4508167781575633
      ],
      "constraints": [
        false,
        true,
        true
      ],
      "feasible": false,
      "feasibilityProb": 0.6947476573081576,
      "timestamp": 1756801176209
    },
    {
      "id": 15,
      "design": [
        0.8133103040896843,
        -0.6830474495340153,
        0.740085786230607,
        0.8127245012192477,
        0.9620570752018647
      ],
      "objectives": [
        0.7421266008116723,
        0.6298211423058762,
        0.6049148064404473,
        0.8113800628764186,
        0.352201313868048,
        0.6801159820486399,
        0.45379995263798206
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.7227475132898362,
      "timestamp": 1756801176212
    },
    {
      "id": 16,
      "design": [
        0.4047601551064681,
        0.9800256232062279,
        0.9652512065061625,
        0.8132853008593628,
        -0.7655430629761233
      ],
      "objectives": [
        0.7734599263259389,
        0.6013657924442748,
        0.5141073654278554,
        0.9027556867791877,
        0.5315813306658369,
        0.5722980674646906,
        0.39064093902092434
      ],
      "constraints": [
        true,
        false,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.493777451733197,
      "timestamp": 1756801176217
    },
    {
      "id": 17,
      "design": [
        0.9785165641901032,
        -0.32351798364309703,
        0.9216381726322735,
        -0.8883602166885551,
        -0.8693018102997705
      ],
      "objectives": [
        0.807745148326905,
        0.7148261640108493,
        0.5110636127475,
        0.8232048154020266,
        0.5939548763479311,
        0.6353442970450534,
        0.42383744161638776
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.6950764811385056,
      "timestamp": 1756801176220
    },
    {
      "id": 18,
      "design": [
        0.9383889281038182,
        -0.20533821664706609,
        -0.887967372401923,
        -0.6725557008745082,
        0.7174599484878774
      ],
      "objectives": [
        0.8080857243660795,
        0.5942338827999099,
        0.5443825499914385,
        0.8675887621884976,
        0.3116814763595685,
        0.6567368746032233,
        0.5307648740046406
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.6771023225984298,
      "timestamp": 1756801176224
    },
    {
      "id": 19,
      "design": [
        0.22115529277693802,
        -0.27844287656644373,
        -0.9704641242790648,
        0.8673875623655238,
        -0.40733769728250446
      ],
      "objectives": [
        0.9052449284077909,
        0.6035094907739006,
        0.49754990326723847,
        0.9183558809775514,
        0.4306822721424207,
        0.7138544689825069,
        0.48714954718053954
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.8184021196380686,
      "timestamp": 1756801176228
    },
    {
      "id": 20,
      "design": [
        -0.841105024723636,
        -0.19050729669006472,
        0.21625773762391365,
        -0.9600223917300756,
        -0.9363313127155006
      ],
      "objectives": [
        0.6836120474639206,
        0.9169499471623781,
        0.49793092303601744,
        0.8483387085243586,
        0.5910655984924894,
        0.6039718414583974,
        0.4292198733338593
      ],
      "constraints": [
        false,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.597945316083477,
      "timestamp": 1756801176232
    },
    {
      "id": 21,
      "design": [
        0.9034920034769955,
        0.40435548657986864,
        -0.16894197797229205,
        0.992541312123395,
        0.7690113319669045
      ],
      "objectives": [
        0.8268773197297811,
        0.7746152513406918,
        0.6484110649040933,
        0.8471080984025151,
        0.3243157962076277,
        0.6133924772328138,
        0.404518082565942
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.8666328737892335,
      "timestamp": 1756801176238
    },
    {
      "id": 22,
      "design": [
        0.3468455931508092,
        0.1382487714921079,
        -0.09076726151655823,
        -0.8815708166211482,
        -0.027977241467997738
      ],
      "objectives": [
        1.0,
        0.9000187338226836,
        0.5418255420324104,
        0.9542762219349662,
        0.1523301061763828,
        0.6030627904082823,
        0.2100837496825774
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.792877761525717,
      "timestamp": 1756801176242
    },
    {
      "id": 23,
      "design": [
        0.16729568193253486,
        -0.9172427850999854,
        0.00868719731677059,
        -0.596230695137222,
        0.849148508918439
      ],
      "objectives": [
        0.7220818228277921,
        0.6069850015263206,
        0.5328876342377638,
        0.8531115768486698,
        0.32561568685524944,
        0.6246183426707311,
        0.45582257892482897
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176246
    },
    {
      "id": 24,
      "design": [
        0.8290085746638629,
        0.9201878420406915,
        -0.9688035939197601,
        -0.9087665172054042,
        0.1951023054829839
      ],
      "objectives": [
        0.7858371642440829,
        0.5679854289712234,
        0.48630066417937123,
        0.8832511624358937,
        0.10993471226194412,
        0.5688359523566571,
        0.4580381538052836
      ],
      "constraints": [
        true,
        false,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.6281464358815008,
      "timestamp": 1756801176250
    },
    {
      "id": 25,
      "design": [
        0.07344596218846267,
        -0.08009637021995997,
        -0.5132642771379812,
        0.26510097673804767,
        0.9584689785079707
      ],
      "objectives": [
        0.9201382064543185,
        0.6693716606686307,
        0.6279578817812539,
        0.8916511886904672,
        0.4272054112842444,
        1.0,
        0.47284010106372026
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176255
    },
    {
      "id": 26,
      "design": [
        -0.9789211079313742,
        -0.5030809235684239,
        0.9073330466970999,
        0.1317693840588705,
        -0.6768725752170808
      ],
      "objectives": [
        0.7074762369955019,
        0.6517144490350244,
        0.5881475499772415,
        0.8343507243379193,
        0.6588245783668872,
        0.9143130645596659,
        0.3954720717360911
      ],
      "constraints": [
        false,
        true,
        true
      ],
      "feasible": false,
      "feasibilityProb": 0.7852044607884503,
      "timestamp": 1756801176259
    },
    {
      "id": 27,
      "design": [
        -0.2991513094029119,
        -0.9780316630290458,
        0.5672608062421145,
        -0.5045875084119531,
        -0.04790439321285511
      ],
      "objectives": [
        0.7058104712621337,
        0.5946631043563967,
        0.50047181839069,
        0.7722838072609074,
        0.4788923450403122,
        0.6812044467039536,
        0.05585574017632267
      ],
      "constraints": [
        true,
        true,
        true
      ],
      "feasible": true,
      "feasibilityProb": 1.0,
      "timestamp": 1756801176264
    },
    {
      "id": 28,
      "design": [
        -0.7968765562421334,
        0.4250608235616731,
        0.12609120757330294,
        -0.7707475277310689,
        0.7654934407774496
      ],
      "objectives": [
        0.7342970042252335,
        0.9266728056828355,
        0.5123192334691068,
        0.8524634182630132,
        0.5925321070317495,
        0.5742447182040663,
        0.39271698523378157
      ],
      "constraints": [
        false,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.5653509961881369,
      "timestamp": 1756801176269
    },
    {
      "id": 29,
      "design": [
        -0.35221834794842843,
        -0.6943782418180839,
        0.03724936336636797,
        0.8820135795742519,
        -0.8109023606504593
      ],
      "objectives": [
        0.7652009672672391,
        0.6951953838353948,
        0.7464032687223479,
        0.8457049225155011,
        0.6356263873398166,
        0.6277167869879607,
        0.3991576235479496
      ],
      "constraints": [
        true,
        true,
        false
      ],
      "feasible": false,
      "feasibilityProb": 0.734701050122838,
      "timestamp": 1756801176274
    }
  ],
  "objectiveNames": [
    "Pressure Recovery",
    "Mixing Efficiency",
    "Heat Transfer",
    "Turbulence Intensity",
    "Wall Shear Stress",
    "Flow Uniformity",
    "Energy Dissipation"
  ],
  "designNames": [
    "Inlet Velocity",
    "Turb. Intensity",
    "k-\u03c9 SST a1",
    "Wall y+",
    "Outlet Pressure"
  ],
  "constraintNames": [
    "Reynolds Number",
    "Convergence",
    "CFL Number"
  ]
};
        
        console.log('Loaded Python data:', {
            samples: pythonData.samples.length,
            objectives: pythonData.objectiveNames,
            feasible: pythonData.samples.filter(s => s.feasible).length
        });
        
        // ================================================
        // GLOBAL VARIABLES
        // ================================================
        let radVizScene, radVizCamera, radVizRenderer;
        let radVizAnchors = [];
        let radVizSamples = [];
        let radVizRotating = true;
        let radVizSphere = null;
        let radVizWireframe = null;
        let is3D = true;
        let sphereColorMode = 'none';
        let sphereHeatmapMesh = null;
        let sceneInitialized = false;
        
        // ================================================
        // DATA CLASS (READ-ONLY FROM PYTHON)
        // ================================================
        class ManyObjectiveBO {
            constructor() {
                this.samples = pythonData.samples || [];
                this.designVariables = pythonData.samples.map(s => s.design);
                this.objectives = pythonData.samples.map(s => s.objectives);
                this.constraints = pythonData.samples.map(s => s.constraints);
                this.iteration = pythonData.samples.length;
                this.objectiveNames = pythonData.objectiveNames;
                this.designNames = pythonData.designNames;
                this.constraintNames = pythonData.constraintNames;
            }
            
            getParetoFront() {
                const feasible = this.samples.filter(s => s.feasible);
                const pareto = [];
                
                feasible.forEach((s1, i) => {
                    let dominated = false;
                    feasible.forEach((s2, j) => {
                        if (i !== j && this.isDominated(s1.objectives, s2.objectives)) {
                            dominated = true;
                        }
                    });
                    if (!dominated) pareto.push(s1);
                });
                
                return pareto;
            }
            
            isDominated(obj1, obj2) {
                let betterInAny = false;
                let worseInAny = false;
                
                for (let i = 0; i < obj1.length; i++) {
                    if (obj1[i] > obj2[i]) betterInAny = true;
                    if (obj1[i] < obj2[i]) worseInAny = true;
                }
                
                return !betterInAny && worseInAny;
            }
            
            computeHypervolume() {
                const pareto = this.getParetoFront();
                if (pareto.length === 0) return 0;
                
                const bestValues = Array(7).fill(0);
                pareto.forEach(p => {
                    p.objectives.forEach((obj, i) => {
                        bestValues[i] = Math.max(bestValues[i], obj);
                    });
                });
                
                return bestValues.reduce((prod, val) => prod * val, 1);
            }
        }
        
        const mobo = new ManyObjectiveBO();
        
        // ================================================
        // 3D VISUALIZATION
        // ================================================
        function init3DRadViz() {
            const canvas = document.getElementById('radviz-canvas');
            if (!canvas) return;
            
            radVizScene = new THREE.Scene();
            radVizScene.background = new THREE.Color(0x1a1a2e);
            
            radVizCamera = new THREE.PerspectiveCamera(
                60, 
                canvas.clientWidth / canvas.clientHeight, 
                0.1, 
                100
            );
            radVizCamera.position.set(5, 4, 5);
            radVizCamera.lookAt(0, 0, 0);
            
            radVizRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true
            });
            radVizRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            radVizScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            radVizScene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.6);
            pointLight.position.set(-5, 5, -5);
            radVizScene.add(pointLight);
            
            // Create anchors and sphere
            createRadVizAnchors();
            sceneInitialized = true;
            
            // Mouse controls
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => mouseDown = false);
            
            canvas.addEventListener('mousemove', (event) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                if (mouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(radVizCamera.position);
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    radVizCamera.position.setFromSpherical(spherical);
                    radVizCamera.lookAt(0, 0, 0);
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                } else {
                    // Hover detection
                    raycaster.setFromCamera(mouse, radVizCamera);
                    const sampleMeshes = radVizSamples.map(s => s.mesh).filter(m => m);
                    const intersects = raycaster.intersectObjects(sampleMeshes);
                    
                    if (intersects.length > 0) {
                        const sampleData = intersects[0].object.userData;
                        if (sampleData) {
                            showTooltipForSample(sampleData, event);
                            canvas.style.cursor = 'pointer';
                        }
                    } else {
                        hideTooltip();
                        canvas.style.cursor = 'grab';
                    }
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                hideTooltip();
                canvas.style.cursor = 'grab';
                mouseDown = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const delta = event.deltaY * 0.01;
                const distance = radVizCamera.position.length();
                const newDistance = Math.max(3, Math.min(10, distance + delta));
                radVizCamera.position.normalize().multiplyScalar(newDistance);
                radVizCamera.lookAt(0, 0, 0);
            });
            
            animateRadViz();
        }
        
        function createRadVizAnchors() {
            const sphereRadius = 2;
            const n = mobo.objectiveNames.length;
            const colors = [
                0xff6666, 0x66b3ff, 0x66ff66, 0xffaa00, 
                0xff66ff, 0x66ffff, 0xffff66
            ];
            
            // Clear existing
            radVizAnchors.forEach(anchor => {
                if (anchor.mesh) radVizScene.remove(anchor.mesh);
                if (anchor.label) radVizScene.remove(anchor.label);
                if (anchor.line) radVizScene.remove(anchor.line);
            });
            radVizAnchors = [];
            
            if (radVizWireframe) radVizScene.remove(radVizWireframe);
            if (radVizSphere) radVizScene.remove(radVizSphere);
            
            // Create sphere wireframe
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 24, 12);
            const sphereWireframeGeometry = new THREE.WireframeGeometry(sphereGeometry);
            radVizWireframe = new THREE.LineSegments(sphereWireframeGeometry);
            radVizWireframe.material.opacity = 0.3;
            radVizWireframe.material.transparent = true;
            radVizWireframe.material.color = new THREE.Color(0x6688ff);
            radVizScene.add(radVizWireframe);
            
            // Semi-transparent sphere
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaccff,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            radVizSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            radVizScene.add(radVizSphere);
            
            // Create anchor points
            for (let i = 0; i < n; i++) {
                const phi = Math.acos(1 - 2 * (i + 0.5) / n);
                const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                
                const x = Math.sin(phi) * Math.cos(theta) * sphereRadius;
                const y = Math.sin(phi) * Math.sin(theta) * sphereRadius;
                const z = Math.cos(phi) * sphereRadius;
                
                // Anchor sphere
                const anchorGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                const anchorMaterial = new THREE.MeshPhongMaterial({
                    color: colors[i],
                    emissive: colors[i],
                    emissiveIntensity: 0.5
                });
                const anchorSphere = new THREE.Mesh(anchorGeometry, anchorMaterial);
                anchorSphere.position.set(x, y, z);
                
                // Line from center
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(x, y, z)
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: colors[i],
                    opacity: 0.4,
                    transparent: true
                });
                const anchorLine = new THREE.Line(lineGeometry, lineMaterial);
                
                radVizScene.add(anchorSphere);
                radVizScene.add(anchorLine);
                
                radVizAnchors.push({
                    mesh: anchorSphere,
                    position: new THREE.Vector3(x, y, z),
                    index: i,
                    line: anchorLine
                });
            }
            
            updateRadViz();
        }
        
        function updateRadViz() {
            if (!sceneInitialized || !radVizScene || !radVizAnchors || radVizAnchors.length === 0) {
                return;
            }
            
            // Clear existing samples
            radVizSamples.forEach(s => {
                if (s.mesh) radVizScene.remove(s.mesh);
                if (s.outline) radVizScene.remove(s.outline);
            });
            radVizSamples = [];
            
            // Remove old sphere coloring mesh if exists
            if (sphereHeatmapMesh) {
                radVizScene.remove(sphereHeatmapMesh);
                sphereHeatmapMesh = null;
            }
            
            const showSphere = document.getElementById('show-sphere') ? document.getElementById('show-sphere').checked : true;
            
            // Show/hide sphere structure
            if (radVizSphere) radVizSphere.visible = showSphere && sphereColorMode === 'none';
            if (radVizWireframe) radVizWireframe.visible = showSphere;
            
            // Add sphere coloring based on mode
            if (showSphere && sphereColorMode !== 'none' && mobo.samples.length > 0) {
                createColoredSphere();
            }
            
            // Add samples with PROPER SIZING
            // When sphere is colored, only show Pareto points
            if (sphereColorMode !== 'none') {
                // Only show Pareto optimal points when mesh is displayed
                const pareto = mobo.getParetoFront();
                
                pareto.forEach((sample) => {
                    let position = new THREE.Vector3(0, 0, 0);
                    let totalWeight = 0;
                    
                    sample.objectives.forEach((value, i) => {
                        if (radVizAnchors[i]) {
                            const weight = value;
                            position.add(
                                radVizAnchors[i].position.clone().multiplyScalar(weight)
                            );
                            totalWeight += weight;
                        }
                    });
                    
                    if (totalWeight > 0) {
                        position.divideScalar(totalWeight);
                    }
                    
                    // Subtle white spheres with gold outline for Pareto points
                    const geometry = new THREE.SphereGeometry(0.04, 16, 16);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xffffff,  // White
                        emissive: 0xffd700,  // Gold glow
                        emissiveIntensity: 0.3  // Subtle glow
                    });
                    
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.copy(position);
                    sphere.userData = sample;
                    
                    // Add subtle golden outline
                    const outlineGeometry = new THREE.SphereGeometry(0.045, 16, 16);
                    const outlineMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffd700,
                        side: THREE.BackSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outline.position.copy(position);
                    
                    radVizScene.add(sphere);
                    radVizScene.add(outline);
                    radVizSamples.push({ mesh: sphere, outline: outline });
                });
                
            } else {
                // When no sphere coloring, show all points with traditional colors
                mobo.samples.forEach((sample) => {
                    let position = new THREE.Vector3(0, 0, 0);
                    let totalWeight = 0;
                    
                    sample.objectives.forEach((value, i) => {
                        if (radVizAnchors[i]) {
                            const weight = value;
                            position.add(
                                radVizAnchors[i].position.clone().multiplyScalar(weight)
                            );
                            totalWeight += weight;
                        }
                    });
                    
                    if (totalWeight > 0) {
                        position.divideScalar(totalWeight);
                    }
                    
                    // Traditional coloring when no sphere mesh
                    let geometry;
                    if (sample.feasible) {
                        geometry = new THREE.SphereGeometry(0.04, 16, 16);
                    } else {
                        geometry = new THREE.OctahedronGeometry(0.035, 0);
                    }
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: sample.feasible ? 0x00ff00 : 0xff0000,
                        emissive: sample.feasible ? 0x00ff00 : 0xff0000,
                        emissiveIntensity: 0.5
                    });
                    
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.copy(position);
                    sphere.userData = sample;
                    
                    radVizScene.add(sphere);
                    radVizSamples.push({ mesh: sphere });
                });
                
                // Highlight Pareto points when showing all
                const pareto = mobo.getParetoFront();
                pareto.forEach(p => {
                    const sampleMesh = radVizSamples.find(s => s.mesh.userData.id === p.id);
                    if (sampleMesh) {
                        sampleMesh.mesh.material.color.setHex(0xffd700);
                        sampleMesh.mesh.material.emissive.setHex(0xffd700);
                        sampleMesh.mesh.material.emissiveIntensity = 0.8;
                        sampleMesh.mesh.scale.set(1.3, 1.3, 1.3);
                    }
                });
            }
        }
        
        function createColoredSphere() {
            if (!radVizAnchors || radVizAnchors.length === 0) return;
            
            const sphereRadius = 2;
            const resolution = 32;
            const geometry = new THREE.SphereGeometry(sphereRadius, resolution, resolution);
            
            // Create color array for vertices
            const colors = [];
            const positions = geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                const vertex = new THREE.Vector3(x, y, z);
                
                // Back-calculate what objectives would place a point here
                const objectives = estimateObjectivesFromPosition(vertex);
                
                // Use surrogate model to predict feasibility and values
                const prediction = evaluateSurrogate(objectives);
                
                let color = new THREE.Color();
                
                if (sphereColorMode === 'feasibility') {
                    // Color by predicted feasibility probability
                    const feasProb = prediction.feasibilityProb;
                    
                    if (feasProb < 0.25) {
                        color.setRGB(1.0, 0.0, 0.0); // Red
                    } else if (feasProb < 0.5) {
                        const t = (feasProb - 0.25) / 0.25;
                        color.setRGB(1.0, t, 0.0); // Red to yellow
                    } else if (feasProb < 0.75) {
                        const t = (feasProb - 0.5) / 0.25;
                        color.setRGB(1.0 - t, 1.0, 0.0); // Yellow to green
                    } else {
                        color.setRGB(0.0, 1.0, 0.0); // Green
                    }
                    
                } else if (sphereColorMode === 'constraints') {
                    // Color by predicted constraint violations
                    const violations = prediction.expectedViolations;
                    
                    if (violations < 0.5) {
                        color.setRGB(0.0, 1.0, 0.2); // Green
                    } else if (violations < 1.5) {
                        const t = (violations - 0.5);
                        color.setRGB(t, 1.0, 0.0); // Green to yellow
                    } else if (violations < 2.5) {
                        const t = (violations - 1.5);
                        color.setRGB(1.0, 1.0 - t * 0.5, 0.0); // Yellow to orange
                    } else {
                        color.setRGB(1.0, 0.0, 0.0); // Red
                    }
                    
                } else if (sphereColorMode.startsWith('obj')) {
                    // Color by specific objective value
                    const objIndex = parseInt(sphereColorMode.substring(3));
                    const value = objectives[objIndex];
                    
                    // Use color scale for objective
                    const hue = (1.0 - value) * 0.7; // Red to blue
                    const saturation = 0.9;
                    const lightness = 0.5;
                    color.setHSL(hue, saturation, lightness);
                    
                } else {
                    // Default gray
                    color.setRGB(0.5, 0.5, 0.5);
                }
                
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.3, // Default opacity
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            sphereHeatmapMesh = new THREE.Mesh(geometry, material);
            sphereHeatmapMesh.renderOrder = -1; // Render behind points
            radVizScene.add(sphereHeatmapMesh);
        }
        
        function estimateObjectivesFromPosition(position) {
            const n = mobo.objectiveNames.length;
            const objectives = new Array(n).fill(0);
            
            if (!radVizAnchors || radVizAnchors.length === 0) {
                return objectives.map(() => 0.5);
            }
            
            // Normalize position to unit sphere
            const normalizedPos = position.clone().normalize();
            
            // Calculate weighted contribution from each anchor
            let totalWeight = 0;
            
            for (let i = 0; i < n; i++) {
                if (radVizAnchors[i]) {
                    const anchorPos = radVizAnchors[i].position.clone().normalize();
                    
                    // Angular distance on sphere surface
                    const dotProduct = normalizedPos.dot(anchorPos);
                    const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
                    
                    // Convert angle to weight
                    const weight = Math.exp(-angle * angle * 2);
                    
                    objectives[i] = weight;
                    totalWeight += weight;
                }
            }
            
            // Normalize objectives to sum to 1
            if (totalWeight > 0) {
                for (let i = 0; i < n; i++) {
                    objectives[i] = objectives[i] / totalWeight;
                }
            }
            
            return objectives;
        }
        
        function evaluateSurrogate(objectives) {
            // Simple surrogate model based on Python samples
            const avgObj = objectives.reduce((a, b) => a + b, 0) / objectives.length;
            const variance = objectives.reduce((sum, obj) => sum + Math.pow(obj - avgObj, 2), 0) / objectives.length;
            
            // Base feasibility from objective quality
            let feasibilityProb = 0.5;
            feasibilityProb += avgObj * 0.3;
            feasibilityProb += (0.3 - variance) * 0.5;
            
            // Learn from Python samples
            if (mobo.samples.length > 0) {
                let totalWeight = 0;
                let weightedAdjustment = 0;
                
                mobo.samples.forEach(sample => {
                    // Calculate distance in objective space
                    let dist = 0;
                    for (let i = 0; i < objectives.length; i++) {
                        dist += Math.pow(objectives[i] - sample.objectives[i], 2);
                    }
                    dist = Math.sqrt(dist);
                    
                    // Gaussian kernel
                    const kernel = Math.exp(-dist * dist / 0.3);
                    
                    totalWeight += kernel;
                    
                    // Adjust based on sample's feasibility
                    const samplePrediction = sample.feasible ? 0.8 : 0.2;
                    weightedAdjustment += kernel * (samplePrediction - feasibilityProb);
                });
                
                if (totalWeight > 0.01) {
                    feasibilityProb += weightedAdjustment / totalWeight * 0.7;
                }
            }
            
            // Bound to valid probability
            feasibilityProb = Math.min(0.95, Math.max(0.05, feasibilityProb));
            
            // Expected violations based on feasibility
            const expectedViolations = (1 - feasibilityProb) * 2.5;
            
            return {
                feasibilityProb: feasibilityProb,
                expectedViolations: expectedViolations
            };
        }
        
        function animateRadViz() {
            requestAnimationFrame(animateRadViz);
            
            if (radVizRotating && radVizScene) {
                radVizScene.rotation.y += 0.003;
            }
            
            if (radVizRenderer && radVizScene && radVizCamera) {
                radVizRenderer.render(radVizScene, radVizCamera);
            }
        }
        
        // ================================================
        // 2D RADVIZ
        // ================================================
        function update2DRadViz() {
            const div = document.getElementById('radviz-2d');
            if (!div) return;
            
            const n = mobo.objectiveNames.length;
            const colors = ['#ff6666', '#66b3ff', '#66ff66', '#ffaa00', '#ff66ff', '#66ffff', '#ffff66'];
            
            // Calculate anchor positions in 2D circle
            const anchors = [];
            for (let i = 0; i < n; i++) {
                const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
                anchors.push({
                    x: Math.cos(angle) * 0.4 + 0.5,
                    y: Math.sin(angle) * 0.4 + 0.5,
                    name: mobo.objectiveNames[i],
                    color: colors[i]
                });
            }
            
            const traces = [];
            
            // Create colored mesh background (same as 3D sphere but projected to 2D)
            if (sphereColorMode !== 'none' && mobo.samples.length > 0) {
                // Create a grid of points for the background mesh
                const resolution = 40;
                const meshZ = [];
                
                for (let i = 0; i <= resolution; i++) {
                    const row = [];
                    for (let j = 0; j <= resolution; j++) {
                        const x = j / resolution;
                        const y = i / resolution;
                        
                        // Convert to circle coordinates
                        const dx = (x - 0.5) * 2;
                        const dy = (y - 0.5) * 2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist <= 0.8) { // Within circle radius
                            // Calculate objectives for this position
                            const pos2D = { x: x, y: y };
                            const objectives = estimateObjectivesFrom2DPosition(pos2D, anchors);
                            
                            // Use same surrogate evaluation as 3D
                            const prediction = evaluateSurrogate(objectives);
                            
                            let value = 0;
                            if (sphereColorMode === 'feasibility') {
                                value = prediction.feasibilityProb;
                            } else if (sphereColorMode === 'constraints') {
                                value = 1.0 - (prediction.expectedViolations / 3.0);
                            } else if (sphereColorMode.startsWith('obj')) {
                                const objIndex = parseInt(sphereColorMode.substring(3));
                                value = objectives[objIndex];
                            }
                            
                            row.push(value);
                        } else {
                            row.push(null); // Outside circle
                        }
                    }
                    meshZ.push(row);
                }
                
                // Create heatmap trace for background
                const heatmapTrace = {
                    x: Array.from({length: resolution + 1}, (_, i) => i / resolution),
                    y: Array.from({length: resolution + 1}, (_, i) => i / resolution),
                    z: meshZ,
                    type: 'heatmap',
                    colorscale: sphereColorMode === 'feasibility' ? [
                        [0, '#ff0000'],
                        [0.25, '#ff8800'],
                        [0.5, '#ffff00'],
                        [0.75, '#88ff00'],
                        [1, '#00ff00']
                    ] : 'RdYlBu',
                    showscale: false,
                    hoverinfo: 'skip',
                    opacity: 0.7
                };
                traces.push(heatmapTrace);
            }
            
            // Add circle outline
            const circleTrace = {
                x: Array.from({length: 101}, (_, i) => Math.cos(i * 2 * Math.PI / 100) * 0.4 + 0.5),
                y: Array.from({length: 101}, (_, i) => Math.sin(i * 2 * Math.PI / 100) * 0.4 + 0.5),
                mode: 'lines',
                line: { color: '#fff', width: 3 },
                showlegend: false,
                hoverinfo: 'skip'
            };
            traces.push(circleTrace);
            
            // Add anchor points
            const anchorTrace = {
                x: anchors.map(a => a.x),
                y: anchors.map(a => a.y),
                mode: 'markers+text',
                marker: { 
                    size: 15, 
                    color: colors,
                    line: { color: 'white', width: 2 }
                },
                text: anchors.map(a => a.name.substring(0, 8)),
                textposition: 'top center',
                textfont: { color: 'white', size: 11 },
                showlegend: false,
                hoverinfo: 'text'
            };
            traces.push(anchorTrace);
            
            // Calculate sample positions
            function calculatePosition(objectives) {
                let x = 0, y = 0;
                let totalWeight = 0;
                objectives.forEach((value, i) => {
                    x += anchors[i].x * value;
                    y += anchors[i].y * value;
                    totalWeight += value;
                });
                if (totalWeight > 0) {
                    x /= totalWeight;
                    y /= totalWeight;
                }
                return { x, y };
            }
            
            // ONLY display Pareto optimal points when mesh is shown
            const pareto = mobo.getParetoFront();
            
            if (pareto.length > 0) {
                const positions = pareto.map(s => calculatePosition(s.objectives));
                
                // Subtle markers for Pareto points
                traces.push({
                    x: positions.map(p => p.x),
                    y: positions.map(p => p.y),
                    mode: 'markers',
                    marker: { 
                        size: 10,
                        color: '#ffffff',  // White centers
                        symbol: 'circle',
                        line: { 
                            color: '#ffd700',  // Gold outline
                            width: 2 
                        }
                    },
                    name: 'Pareto Optimal',
                    text: pareto.map(s => `Sample ${s.id}`),
                    hovertemplate: '<b>Pareto Optimal</b><br>Sample %{text}<extra></extra>'
                });
                
                // Add subtle glow effect with larger transparent circles
                traces.push({
                    x: positions.map(p => p.x),
                    y: positions.map(p => p.y),
                    mode: 'markers',
                    marker: { 
                        size: 16,
                        color: 'rgba(255, 215, 0, 0.2)',  // Transparent gold glow
                        symbol: 'circle'
                    },
                    showlegend: false,
                    hoverinfo: 'skip'
                });
            }
            
            const layout = {
                xaxis: { range: [0, 1], showgrid: false, zeroline: false, showticklabels: false },
                yaxis: { range: [0, 1], showgrid: false, zeroline: false, showticklabels: false, scaleanchor: 'x' },
                paper_bgcolor: '#2a2a3e',
                plot_bgcolor: '#2a2a3e',
                height: 380,
                margin: { l: 20, r: 20, t: 20, b: 20 },
                showlegend: true,
                legend: { x: 1, y: 1, bgcolor: 'rgba(0,0,0,0.5)', font: { color: 'white' } }
            };
            
            Plotly.newPlot('radviz-2d', traces, layout, {responsive: true});
        }
        
        // Helper function to estimate objectives from 2D position
        function estimateObjectivesFrom2DPosition(position, anchors) {
            const n = anchors.length;
            const objectives = new Array(n).fill(0);
            
            // Simple approximation based on distance to anchors
            let totalWeight = 0;
            
            for (let i = 0; i < n; i++) {
                const dist = Math.sqrt(
                    Math.pow(position.x - anchors[i].x, 2) + 
                    Math.pow(position.y - anchors[i].y, 2)
                );
                // Inverse distance weighting
                const weight = 1.0 / (dist + 0.1);
                objectives[i] = weight;
                totalWeight += weight;
            }
            
            // Normalize
            if (totalWeight > 0) {
                for (let i = 0; i < n; i++) {
                    objectives[i] = objectives[i] / totalWeight;
                }
            }
            
            return objectives;
        }
        
        // ================================================
        // OTHER VISUALIZATIONS
        // ================================================
        function updateRadarChart() {
            if (mobo.samples.length === 0) return;
            
            const recentSamples = mobo.samples.slice(-5);
            
            const traces = recentSamples.map((sample, idx) => ({
                type: 'scatterpolar',
                r: sample.objectives,
                theta: mobo.objectiveNames,
                fill: 'toself',
                name: `Sample ${sample.id}`,
                fillcolor: sample.feasible ? 
                    `rgba(52, 152, 219, ${0.1 + idx * 0.1})` : 
                    `rgba(231, 76, 60, ${0.1 + idx * 0.1})`,
                line: {
                    color: sample.feasible ? '#3498db' : '#e74c3c'
                }
            }));
            
            const layout = {
                polar: {
                    radialaxis: {
                        visible: true,
                        range: [0, 1]
                    }
                },
                showlegend: true,
                margin: { l: 50, r: 50, t: 50, b: 50 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                height: 380
            };
            
            Plotly.newPlot('radar-plot', traces, layout, {responsive: true});
        }
        
        function updateHeatmap() {
            if (mobo.samples.length === 0) return;
            
            const z = mobo.samples.map(s => s.objectives);
            const y = mobo.samples.map(s => `S${s.id}`);
            const x = mobo.objectiveNames;
            
            const trace = {
                type: 'heatmap',
                z: z,
                x: x,
                y: y,
                colorscale: 'RdYlGn',
                colorbar: {
                    title: 'Value',
                    titleside: 'right'
                }
            };
            
            const layout = {
                xaxis: { 
                    side: 'bottom',
                    tickangle: -45
                },
                yaxis: { 
                    autorange: 'reversed'
                },
                margin: { l: 60, r: 100, t: 30, b: 100 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                height: 350
            };
            
            Plotly.newPlot('heatmap-plot', [trace], layout, {responsive: true});
        }
        
        function updateConstraintDisplay() {
            const html = `
                <div style="padding: 10px;">
                    <h4>Sample Statistics</h4>
                    <p>Total Samples: ${mobo.samples.length}</p>
                    <p>Feasible: ${mobo.samples.filter(s => s.feasible).length}</p>
                    <p>Infeasible: ${mobo.samples.filter(s => !s.feasible).length}</p>
                    <br>
                    <h4>Constraint Summary</h4>
                    ${mobo.constraintNames.map((name, idx) => {
                        const violations = mobo.samples.filter(s => !s.constraints[idx]).length;
                        const percentage = ((mobo.samples.length - violations) / mobo.samples.length * 100).toFixed(1);
                        return `<p>${name}: ${percentage}% satisfied</p>`;
                    }).join('')}
                </div>
            `;
            document.getElementById('constraints-display').innerHTML = html;
        }
        
        function updateStats() {
            document.getElementById('samples-count').textContent = mobo.samples.length;
            document.getElementById('hypervolume').textContent = mobo.computeHypervolume().toFixed(3);
            
            const feasibleCount = mobo.samples.filter(s => s.feasible).length;
            document.getElementById('feasible').textContent = `${feasibleCount}/${mobo.samples.length}`;
            
            const paretoCount = mobo.getParetoFront().length;
            document.getElementById('pareto-count').textContent = paretoCount;
        }
        
        // ================================================
        // TOOLTIP FUNCTIONS
        // ================================================
        function showTooltipForSample(sample, event) {
            const tooltip = document.getElementById('tooltip');
            
            let html = `
                <div class="tooltip-header">Sample #${sample.id} ${sample.feasible ? '‚úì' : '‚úó'}</div>
                <div style="margin: 10px 0;">
                    <strong>Objectives:</strong>
                    ${mobo.objectiveNames.map((name, i) => `
                        <div style="display: flex; justify-content: space-between; margin: 2px 0;">
                            <span>${name}:</span>
                            <span>${sample.objectives[i].toFixed(3)}</span>
                        </div>
                    `).join('')}
                </div>
                <div style="margin: 10px 0;">
                    <strong>Feasibility Probability:</strong> ${(sample.feasibilityProb * 100).toFixed(1)}%
                </div>
            `;
            
            tooltip.innerHTML = html;
            tooltip.style.left = Math.min(event.pageX + 10, window.innerWidth - 370) + 'px';
            tooltip.style.top = Math.min(event.pageY - 50, window.innerHeight - 350) + 'px';
            tooltip.classList.add('show');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }
        
        // ================================================
        // CONTROL FUNCTIONS
        // ================================================
        window.toggle2D3D = function() {
            is3D = !is3D;
            const button = event.target;
            if (is3D) {
                document.getElementById('radviz-canvas').style.display = 'block';
                document.getElementById('radviz-2d').style.display = 'none';
                document.getElementById('radviz-title').innerHTML = 'üåê 3D RadViz';
                button.textContent = 'Switch to 2D';
            } else {
                document.getElementById('radviz-canvas').style.display = 'none';
                document.getElementById('radviz-2d').style.display = 'block';
                document.getElementById('radviz-title').innerHTML = '‚≠ï 2D RadViz';
                button.textContent = 'Switch to 3D';
                update2DRadViz();
            }
        }
        
        window.resetRadVizCamera = function() {
            if (radVizCamera) {
                radVizCamera.position.set(5, 4, 5);
                radVizCamera.lookAt(0, 0, 0);
            }
        }
        
        window.toggleRadVizRotation = function() {
            radVizRotating = !radVizRotating;
        }
        
        window.updateSphereColoring = function() {
            sphereColorMode = document.getElementById('sphere-coloring').value;
            updateRadViz();
            // Also update 2D view if it's visible
            if (!is3D) {
                update2DRadViz();
            }
        }
        
        window.updateSphereOpacity = function() {
            const opacity = document.getElementById('sphere-opacity').value / 100;
            if (sphereHeatmapMesh) {
                sphereHeatmapMesh.material.opacity = opacity;
                sphereHeatmapMesh.material.needsUpdate = true;
            }
        }
        
        window.focusParetoFront = function() {
            const pareto = mobo.getParetoFront();
            alert(`Pareto front contains ${pareto.length} optimal solutions\nThey are highlighted in gold in the visualization`);
        }
        
        window.showPythonInfo = function() {
            const info = `
Python Optimization Summary:
- Total Samples: ${mobo.samples.length}
- Feasible Solutions: ${mobo.samples.filter(s => s.feasible).length}
- Pareto Optimal: ${mobo.getParetoFront().length}
- Hypervolume: ${mobo.computeHypervolume().toFixed(4)}
- Data generated at: ${new Date(mobo.samples[0].timestamp).toLocaleString()}
            `;
            alert(info);
        }
        
        window.exportData = function() {
            const dataStr = JSON.stringify(pythonData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'mobo_python_data.json';
            link.click();
        }
        
        // ================================================
        // INITIALIZATION
        // ================================================
        function initVisualizations() {
            updateRadViz();
            updateRadarChart();
            updateHeatmap();
            updateConstraintDisplay();
            updateStats();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing with Python data...');
            init3DRadViz();
            initVisualizations();
            
            // Add event listeners
            const showSphereCheckbox = document.getElementById('show-sphere');
            if (showSphereCheckbox) {
                showSphereCheckbox.addEventListener('change', function() {
                    if (sceneInitialized) {
                        updateRadViz();
                    }
                });
            }
            
            console.log('Visualization ready!');
        });
        
        window.addEventListener('resize', function() {
            if (radVizCamera && radVizRenderer) {
                const canvas = document.getElementById('radviz-canvas');
                radVizCamera.aspect = canvas.clientWidth / canvas.clientHeight;
                radVizCamera.updateProjectionMatrix();
                radVizRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        });
    </script>
</body>
</html>
